{
  "apps/extension/src/background/service-worker.ts": "// BrainBox AI Chat Organizer - Service Worker\n// Manifest V3 Background Script\n\nimport { CONFIG } from '@/lib/config';\nimport { logger } from '@/lib/logger';\nimport { AuthManager } from './modules/authManager';\nimport { PromptSyncManager } from '@brainbox/shared/logic/promptSync';\nimport { DynamicMenus } from './modules/dynamicMenus';\nimport { MessageRouter } from './modules/messageRouter';\nimport { NetworkObserver } from './modules/networkObserver';\nimport { InstallationManager } from './modules/installationManager';\nimport { SyncManager } from './modules/syncManager';\nimport { clearExtensionCache } from '@brainbox/shared';\n\n// ============================================================================\n// LIFECYCLE MANAGEMENT\n// ============================================================================\n\n/**\n * Install event - skip waiting to ensure the new worker takes over immediately\n */\nself.addEventListener('install', () => {\n    logger.info('Worker', '\ud83d\udce5 Service Worker Installing...');\n    (self as any).skipWaiting();\n});\n\n/**\n * Activate event - claim clients to ensure consistent control\n */\nself.addEventListener('activate', (event: any) => {\n    logger.info('Worker', '\u2728 Service Worker Activating...');\n    event.waitUntil((self as any).clients.claim());\n});\n\nlogger.info('Worker', '\ud83d\ude80 Service Worker Starting...');\n\nself.onerror = function(message, source, lineno, colno, error) {\n    logger.error('Worker', '\u274c Global Error: ' + message, error);\n};\n\n// ============================================================================\n// MODULE INITIALIZATION\n// ============================================================================\n\n// 1. Core Managers\nconst authManager = new AuthManager();\nconst promptSyncManager = new PromptSyncManager(CONFIG.DASHBOARD_URL);\n\n// 2. Feature Modules\nconst dynamicMenus = new DynamicMenus(promptSyncManager);\nconst networkObserver = new NetworkObserver(false);\nconst installationManager = new InstallationManager(false);\n\n// 3. Communication Router\nconst messageRouter = new MessageRouter(\n    authManager,\n    promptSyncManager,\n    false\n);\n\n// ============================================================================\n// START ALL MODULES\n// ============================================================================\n\nauthManager.initialize();\npromptSyncManager.initialize();\nclearExtensionCache().catch(() => {});\n\n// Trigger sync queue processing on startup\nchrome.storage.local.get(['accessToken'], ({ accessToken }) => {\n    SyncManager.initialize(accessToken);\n});\n\ndynamicMenus.initialize();\nnetworkObserver.initialize();\ninstallationManager.initialize();\n\nmessageRouter.listen();\n\n// 4. API Proxy Listener (CORS Bridge)\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    if (request.action === 'proxyToFactory') {\n        (async () => {\n             try {\n                const { payload } = request;\n                \n                // Get Auth Token\n                const { accessToken } = await chrome.storage.local.get('accessToken');\n                if (!accessToken) {\n                    throw new Error('No access token available');\n                }\n\n                logger.debug('Worker', '\ud83d\udce1 Proxying to Factory:', CONFIG.API_BASE_URL + '/api/captures/save');\n\n                const response = await fetch(`${CONFIG.API_BASE_URL}/api/captures/save`, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': `Bearer ${accessToken}`\n                    },\n                    body: JSON.stringify(payload)\n                });\n\n                if (response.status === 401) {\n                    logger.error('Worker', '\u274c 401 Unauthorized - Token expired or invalid');\n                    // Potentially trigger re-login flow here\n                    sendResponse({ success: false, error: 'Unauthorized' });\n                    return;\n                }\n\n                if (!response.ok) {\n                     const errorText = await response.text();\n                     throw new Error(`Server error ${response.status}: ${errorText}`);\n                }\n\n                const data = await response.json();\n                sendResponse({ success: true, data });\n\n             } catch (error: any) {\n                 logger.error('Worker', '\u274c Proxy Error:', error);\n                 sendResponse({ success: false, error: error.message });\n             }\n        })();\n        return true; // Keep channel open\n    }\n});\n\n// ============================================================================\n// CONFIGURATION SYNC\n// ============================================================================\n\nchrome.storage.local.set({ \n    API_BASE_URL: CONFIG.API_BASE_URL,\n    DASHBOARD_URL: CONFIG.DASHBOARD_URL,\n    EXTENSION_VERSION: CONFIG.VERSION\n});\n\nlogger.info('Worker', '\u2705 All modules initialized');\n\n",
  "apps/extension/src/background/modules/messageRouter.ts": "/**\n * MessageRouter\n * \n * Central message routing hub with dependency injection\n */\nimport { logger } from '@/lib/logger';\nimport { AuthManager } from './authManager';\nimport { PromptSyncManager } from '@brainbox/shared/logic/promptSync';\nimport * as platformAdapters from './platformAdapters';\nimport * as dashboardApi from './dashboardApi';\nimport { CONFIG } from '@/lib/config';\n\ntype SupportedPlatform = 'chatgpt' | 'claude' | 'gemini' | 'perplexity' | 'deepseek' | 'grok' | 'qwen' | 'lmarena';\n\ninterface MessageRequest {\n    action: string;\n    platform?: SupportedPlatform;\n    conversationId?: string;\n    url?: string;\n    data?: any;\n    payload?: any;\n    folderId?: string;\n    silent?: boolean;\n    accessToken?: string;\n    refreshToken?: string;\n    expiresAt?: number;\n    rememberMe?: boolean;\n    token?: string;\n    [key: string]: any;\n}\n\nexport class MessageRouter {\n    private authManager: AuthManager;\n    private promptSyncManager: PromptSyncManager;\n    private DEBUG_MODE: boolean;\n\n    constructor(\n        authManager: AuthManager,\n        promptSyncManager: PromptSyncManager,\n        debug = false\n    ) {\n        this.authManager = authManager;\n        this.promptSyncManager = promptSyncManager;\n        this.DEBUG_MODE = debug;\n        \n        // Bind handlers\n        this.handleMessage = this.handleMessage.bind(this);\n    }\n\n    /**\n     * Start listening for messages\n     */\n    listen() {\n        chrome.runtime.onMessage.addListener(this.handleMessage);\n        logger.info('MessageRouter', '\ud83d\udce1 Listening for messages...');\n    }\n\n    /**\n     * Main message handler with route delegation\n     */\n    private handleMessage(\n        request: MessageRequest,\n        sender: chrome.runtime.MessageSender,\n        sendResponse: (response?: any) => void\n    ): boolean {\n        // SECURITY: Verify internal origin (skip in test environment)\n        logger.debug(\"MessageRouter\", '\ud83d\udce8 MessageRouter: Received action', request.action, 'from', sender.id, 'Self:', chrome.runtime.id);\n        \n        if (process.env.NODE_ENV !== 'test' && sender.id !== chrome.runtime.id) {\n            console.error('\ud83d\uded1 Blocked external message', { senderId: sender.id, selfId: chrome.runtime.id });\n            logger.warn('MessageRouter', '\ud83d\uded1 Blocked external message', { senderId: sender.id });\n            return false;\n        }\n\n        if (this.DEBUG_MODE) {\n            logger.debug('MessageRouter', `\ud83d\udce8 ${request.action}`, {\n                platform: request.platform,\n                hasData: !!request.data\n            });\n        }\n\n        // Route to appropriate handler\n        switch (request.action) {\n            // ============ AUTH ============\n            case 'setAuthToken':\n                return this.handleSetAuthToken(request, sendResponse);\n            \n            case 'checkDashboardSession':\n                return this.handleCheckSession(sendResponse);\n            \n            case 'syncAll':\n                return this.handleSyncAll(sendResponse);\n\n            // ============ PROMPTS ============\n            case 'fetchPrompts':\n                return this.handleFetchPrompts(sendResponse);\n            \n            case 'syncPrompts':\n                return this.handleSyncPrompts(sendResponse);\n\n            // ============ GEMINI ============\n            case 'injectGeminiMainScript':\n                return this.handleInjectGemini(sender, sendResponse);\n            \n            case 'storeGeminiToken':\n                return this.handleStoreGeminiToken(request, sendResponse);\n\n            // ============ FOLDERS ============\n            case 'getUserFolders':\n                return this.handleGetFolders(sendResponse);\n\n            // ============ CONVERSATIONS ============\n            case 'getConversation':\n                // The original instruction provided an invalid code snippet.\n                // The existing handleGetConversation already passes `request.payload`.\n                // Assuming the intent was to ensure `request.payload` is passed,\n                // the current implementation correctly handles this.\n                // No change is made to the call site as the existing one is correct.\n                return this.handleGetConversation(request, sendResponse);\n            \n            case 'saveToDashboard':\n                return this.handleSaveConversation(request, sendResponse);\n\n            // ============ MISC ============\n            case 'openLoginPage':\n                return this.handleOpenLoginPage(sendResponse);\n\n            default:\n                return false; // Allow other listeners\n        }\n    }\n\n    // ========================================================================\n    // AUTH HANDLERS\n    // ========================================================================\n\n    private handleSetAuthToken(request: MessageRequest, sendResponse: Function): boolean {\n        this.authManager.setDashboardSession({\n            accessToken: request.accessToken,\n            refreshToken: request.refreshToken,\n            expiresAt: request.expiresAt,\n            rememberMe: request.rememberMe\n        }).then(() => {\n            this.promptSyncManager.sync(); // Sync prompts after login\n            sendResponse({ success: true });\n        }).catch(error => {\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Async response\n    }\n\n    private handleCheckSession(sendResponse: Function): boolean {\n        this.authManager.isSessionValid()\n            .then(isValid => sendResponse({ success: true, isValid }))\n            .catch(error => sendResponse({ success: false, error: error.message }));\n        return true;\n    }\n\n    private handleSyncAll(sendResponse: Function): boolean {\n        Promise.all([\n            this.authManager.syncAll(),\n            this.promptSyncManager.sync(true)\n        ]).then(([authResult]) => {\n            sendResponse({ success: true, ...authResult });\n        }).catch(error => {\n            sendResponse({ success: false, error: error.message });\n        });\n        return true;\n    }\n\n    // ========================================================================\n    // PROMPT HANDLERS\n    // ========================================================================\n\n    private handleFetchPrompts(sendResponse: Function): boolean {\n        this.promptSyncManager.getAllPrompts()\n            .then(data => sendResponse({ success: true, data }))\n            .catch(error => sendResponse({ success: false, error: error.message }));\n        return true;\n    }\n\n    private handleSyncPrompts(sendResponse: Function): boolean {\n        this.promptSyncManager.sync()\n            .then(result => sendResponse(result))\n            .catch(error => sendResponse({ success: false, error: error.message }));\n        return true;\n    }\n\n    // ========================================================================\n    // GEMINI HANDLERS\n    // ========================================================================\n\n    private handleInjectGemini(sender: chrome.runtime.MessageSender, sendResponse: Function): boolean {\n        this.injectGeminiScript(sender.tab?.id);\n        sendResponse({ success: true });\n        return true;\n    }\n\n    private handleStoreGeminiToken(request: MessageRequest, sendResponse: Function): boolean {\n        if (request.token) {\n            chrome.storage.local.set({ gemini_at_token: request.token }).then(() => {\n                if (this.DEBUG_MODE) {\n                    logger.debug('MessageRouter', '\u2705 Gemini AT token stored');\n                }\n                sendResponse({ success: true });\n            });\n        } else {\n            sendResponse({ success: true });\n        }\n        return true;\n    }\n\n    // ========================================================================\n    // FOLDER HANDLERS\n    // ========================================================================\n\n    private handleGetFolders(sendResponse: Function): boolean {\n        dashboardApi.getUserFolders()\n            .then(folders => sendResponse({ success: true, folders }))\n            .catch(error => sendResponse({ success: false, error: error.message }));\n        return true;\n    }\n\n    // ========================================================================\n    // CONVERSATION HANDLERS\n    // ========================================================================\n\n    private handleGetConversation(request: MessageRequest, sendResponse: Function): boolean {\n        platformAdapters.fetchConversation(request.platform ?? 'chatgpt', request.conversationId ?? '', request.url ?? '', request.payload)\n            .then(data => sendResponse({ success: true, data }))\n            .catch(error => sendResponse({ success: false, error: error.message }));\n        return true;\n    }\n\n    private handleSaveConversation(request: MessageRequest, sendResponse: Function): boolean {\n        dashboardApi.saveToDashboard(request.data, request.folderId ?? null, request.silent ?? false)\n            .then(result => sendResponse({ success: true, result }))\n            .catch(error => sendResponse({ success: false, error: error.message }));\n        return true;\n    }\n\n    // ========================================================================\n    // MISC HANDLERS\n    // ========================================================================\n\n    private handleOpenLoginPage(sendResponse: Function): boolean {\n        chrome.tabs.create({ url: `${CONFIG.DASHBOARD_URL}/auth/signin?redirect=/extension-auth` });\n        sendResponse({ success: true });\n        return true;\n    }\n\n    // ========================================================================\n    // UTILITIES\n    // ========================================================================\n\n    private async injectGeminiScript(tabId?: number) {\n        if (!tabId) return;\n        try {\n            await chrome.scripting.executeScript({\n                target: { tabId },\n                world: 'MAIN',\n                files: ['src/content/inject-gemini-main.ts']\n            });\n        } catch (e) {\n            logger.error('MessageRouter', 'Gemini script injection failed:', e);\n        }\n    }\n}\n",
  "apps/extension/src/background/modules/dashboardApi.ts": "/**\n * Dashboard API Operations\n * Non-platform-specific API handlers (folders, save)\n */\n\nimport { CONFIG } from '@/lib/config';\nimport { logger } from '@/lib/logger';\nimport { limiters } from '../../lib/rate-limiter.js';\nimport type { Conversation, Message } from './platformAdapters/base';\nimport { CacheManager } from './cacheManager';\nimport { SyncManager } from './syncManager';\nimport type { CreateChatInput } from '@brainbox/validation';\n\nconst debugLog = (msg: string, data?: any) => {\n    logger.debug('DashboardAPI', msg, data);\n};\n\n/**\n * Robust fetch wrapper with HTML guard clause\n * Ensures we don't accidentally parse 404/500 HTML pages as JSON\n */\nasync function fetchWithGuard(url: string, options: RequestInit): Promise<Response> {\n    const response = await fetch(url, options);\n    \n    // Guard Clause: Detect HTML responses when JSON is expected\n    const contentType = response.headers.get('Content-Type');\n    if (contentType && contentType.includes('text/html')) {\n        const text = await response.text();\n        const is404 = text.includes('404') || response.status === 404;\n        debugLog('\ud83d\udea8 HTML response detected instead of JSON!', { \n            status: response.status, \n            url,\n            is404,\n            preview: text.substring(0, 200) \n        });\n        throw new Error(`Unexpected HTML response (${response.status}). Check connectivity or API_BASE_URL.`);\n    }\n    \n    return response;\n}\n\n// --- Optimized Tag Generation Logic (Whitelist based) ---\n\ninterface TagConfig {\n    whitelist: Record<string, number>;\n    regex: RegExp;\n}\n\nconst LANGUAGES: Record<string, TagConfig> = {\n    bg: {\n        regex: /[\u0430-\u044f\u0410-\u042f0-9]+/g,\n        whitelist: {\n            '\u0430\u043b\u0433\u043e\u0440\u0438\u0442\u044a\u043c': 1, '\u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u0430': 1, '\u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0437\u0430\u0446\u0438\u044f': 1, '\u0430\u043d\u0430\u043b\u0438\u0437': 1, '\u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435': 1, '\u0431\u0430\u0437\u0430': 1, '\u0431\u0438\u0437\u043d\u0435\u0441': 1, '\u0431\u044e\u0434\u0436\u0435\u0442': 1, '\u0431\u0440\u0430\u0443\u0437\u044a\u0440': 1, '\u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430': 1,\n            '\u0434\u0438\u0437\u0430\u0439\u043d': 1, '\u0434\u043e\u043c\u0435\u0439\u043d': 1, '\u0434\u043e\u0433\u043e\u0432\u043e\u0440': 1, '\u0434\u043e\u043a\u043b\u0430\u0434': 1, '\u0434\u0430\u043d\u043d\u0438': 1, '\u0434\u0435\u0446\u0430': 1, '\u0434\u0438\u0430\u0433\u043d\u043e\u0437\u0430': 1, '\u0434\u0438\u0435\u0442\u0430': 1, '\u0435\u043a\u043e\u043b\u043e\u0433\u0438\u044f': 1, '\u0435\u043d\u0435\u0440\u0433\u0438\u044f': 1, '\u0435\u0442\u0438\u043a\u0430': 1,\n            '\u0435\u043b\u0435\u043a\u0442\u0440\u043e\u043d\u0438\u043a\u0430': 1, '\u0438\u043a\u043e\u043d\u043e\u043c\u0438\u043a\u0430': 1, '\u0438\u043d\u0432\u0435\u0441\u0442\u0438\u0446\u0438\u044f': 1, '\u0438\u043d\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u044f': 1, '\u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441': 1, '\u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f': 1, '\u0438\u043d\u043e\u0432\u0430\u0446\u0438\u044f': 1, '\u0438\u0437\u043a\u0443\u0441\u0442\u0432\u043e': 1, '\u0438\u0437\u0441\u043b\u0435\u0434\u0432\u0430\u043d\u0435': 1,\n            '\u043a\u0443\u0440\u0441': 1, '\u043a\u0443\u043b\u0442\u0443\u0440\u0430': 1, '\u043a\u043b\u0438\u0435\u043d\u0442': 1, '\u043a\u0440\u0438\u043f\u0442\u0438\u0440\u0430\u043d\u0435': 1, '\u043b\u043e\u0433\u0438\u043a\u0430': 1, '\u043b\u0438\u0434\u0435\u0440\u0441\u0442\u0432\u043e': 1, '\u043b\u043e\u0433\u0438\u0441\u0442\u0438\u043a\u0430': 1, '\u043b\u0435\u043a\u0446\u0438\u044f': 1, '\u043b\u0438\u0442\u0435\u0440\u0430\u0442\u0443\u0440\u0430': 1, '\u043c\u0430\u0440\u043a\u0435\u0442\u0438\u043d\u0433': 1,\n            '\u043c\u0435\u043d\u0438\u0434\u0436\u043c\u044a\u043d\u0442': 1, '\u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u043a\u0430': 1, '\u043c\u0435\u0434\u0438\u0446\u0438\u043d\u0430': 1, '\u043c\u0435\u0434\u0438\u044f': 1, '\u043c\u043e\u0431\u0438\u043b\u0435\u043d': 1, '\u043c\u0443\u0437\u0438\u043a\u0430': 1, '\u043c\u043e\u0434\u0430': 1, '\u043d\u0430\u0443\u043a\u0430': 1, '\u043e\u0431\u0443\u0447\u0435\u043d\u0438\u0435': 1, '\u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0446\u0438\u044f': 1,\n            '\u043e\u0431\u0435\u043a\u0442\u0438': 1, '\u043e\u0431\u0449\u0435\u0441\u0442\u0432\u043e': 1, '\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435': 1, '\u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0430': 1, '\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u0430': 1, '\u043f\u0440\u043e\u0435\u043a\u0442': 1, '\u043f\u0440\u043e\u0446\u0435\u0441': 1, '\u043f\u0430\u0437\u0430\u0440': 1, '\u043f\u043b\u0430\u0449\u0430\u043d\u0435': 1, '\u043f\u043b\u0430\u043d\u0438\u0440\u0430\u043d\u0435': 1,\n            '\u043f\u0441\u0438\u0445\u043e\u043b\u043e\u0433\u0438\u044f': 1, '\u043f\u044a\u0442\u0443\u0432\u0430\u043d\u0435': 1, '\u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0441\u0442\u0432\u043e': 1, '\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430': 1, '\u0440\u0435\u0441\u0443\u0440\u0441': 1, '\u0440\u0435\u043a\u043b\u0430\u043c\u0430': 1, '\u0440\u0435\u0446\u0435\u043f\u0442\u0430': 1, '\u0440\u0435\u0444\u0430\u043a\u0442\u043e\u0440\u0438\u043d\u0433': 1, '\u0440\u043e\u0431\u043e\u0442\u0438\u043a\u0430': 1,\n            '\u0441\u0438\u0433\u0443\u0440\u043d\u043e\u0441\u0442': 1, '\u0441\u044a\u0440\u0432\u044a\u0440': 1, '\u0441\u043e\u0444\u0442\u0443\u0435\u0440': 1, '\u0441\u0442\u0440\u0430\u0442\u0435\u0433\u0438\u044f': 1, '\u0441\u043f\u043e\u0440\u0442': 1, '\u0441\u0438\u0441\u0442\u0435\u043c\u0430': 1, '\u0441\u0442\u0430\u0442\u0438\u044f': 1, '\u0441\u043e\u0446\u0438\u0430\u043b\u043d\u0438': 1, '\u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432\u043e': 1, '\u0441\u0442\u0440\u043e\u0438\u0442\u0435\u043b\u0441\u0442\u0432\u043e': 1,\n            '\u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u044f': 1, '\u0442\u0443\u0440\u0438\u0437\u044a\u043c': 1, '\u0442\u044a\u0440\u0433\u043e\u0432\u0438\u044f': 1, '\u0442\u0435\u0440\u0430\u043f\u0438\u044f': 1, '\u0442\u0440\u0430\u043d\u0441\u043f\u043e\u0440\u0442': 1, '\u0443\u0435\u0431\u0441\u0430\u0439\u0442': 1, '\u0443\u0441\u043b\u0443\u0433\u0430': 1, '\u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435': 1, '\u0444\u0438\u043d\u0430\u043d\u0441\u0438': 1, '\u0444\u0430\u043a\u0442\u0443\u0440\u0430': 1,\n            '\u0444\u0438\u0442\u043d\u0435\u0441': 1, '\u0444\u0438\u0437\u0438\u043a\u0430': 1, '\u0444\u0438\u043b\u043e\u0441\u043e\u0444\u0438\u044f': 1, '\u0444\u0438\u043b\u043c': 1, '\u0445\u0430\u0440\u0434\u0443\u0435\u0440': 1, '\u0445\u043e\u0441\u0442\u0438\u043d\u0433': 1, '\u0445\u0438\u043c\u0438\u044f': 1, '\u0445\u043e\u0442\u0435\u043b': 1, '\u0446\u0435\u043b': 1, '\u0446\u0435\u043d\u0430': 1\n        }\n    },\n    en: {\n        regex: /[a-zA-Z0-9]+/g,\n        whitelist: {\n            'algorithm': 1, 'architecture': 1, 'automation': 1, 'analytics': 1, 'application': 1, 'backend': 1, 'frontend': 1, 'database': 1, 'business': 1, 'budget': 1,\n            'browser': 1, 'library': 1, 'design': 1, 'domain': 1, 'contract': 1, 'report': 1, 'data': 1, 'children': 1, 'diagnosis': 1, 'diet': 1, 'ecology': 1,\n            'energy': 1, 'ethics': 1, 'electronics': 1, 'economy': 1, 'investment': 1, 'integration': 1, 'interface': 1, 'information': 1, 'innovation': 1, 'art': 1,\n            'research': 1, 'course': 1, 'culture': 1, 'client': 1, 'encryption': 1, 'logic': 1, 'leadership': 1, 'logistics': 1, 'lecture': 1, 'literature': 1,\n            'marketing': 1, 'management': 1, 'math': 1, 'medicine': 1, 'media': 1, 'mobile': 1, 'music': 1, 'fashion': 1, 'science': 1, 'training': 1, 'optimization': 1,\n            'objects': 1, 'society': 1, 'education': 1, 'platform': 1, 'program': 1, 'project': 1, 'process': 1, 'market': 1, 'payment': 1, 'planning': 1,\n            'psychology': 1, 'travel': 1, 'production': 1, 'development': 1, 'resource': 1, 'advertising': 1, 'recipe': 1, 'refactoring': 1, 'robotics': 1,\n            'security': 1, 'server': 1, 'software': 1, 'strategy': 1, 'sport': 1, 'system': 1, 'article': 1, 'social': 1, 'family': 1, 'construction': 1,\n            'technology': 1, 'tourism': 1, 'trading': 1, 'therapy': 1, 'transport': 1, 'website': 1, 'service': 1, 'governance': 1, 'finance': 1, 'invoice': 1,\n            'fitness': 1, 'physics': 1, 'philosophy': 1, 'movie': 1, 'hardware': 1, 'hosting': 1, 'chemistry': 1, 'hotel': 1, 'goal': 1, 'price': 1\n        }\n    }\n};\n\nconst stemmers = {\n    bg: (w: string) => w.replace(/(\u0438\u0442\u0435|\u043e\u0432\u0435|\u0442\u0430|\u0442\u043e|\u0442\u0435|\u0442\u0430|\u0438\u044f\u0442|\u044f\u0442|\u0438\u044f|\u044f)$/, '').toLowerCase(),\n    en: (w: string) => w.replace(/(ing|ed|ies|s)$/, '').toLowerCase()\n};\n\n/**\n * \u041e\u0441\u043d\u043e\u0432\u043d\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0437\u0430 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0430\u043d\u0435 \u043d\u0430 \u0442\u0430\u0433\u043e\u0432\u0435\n */\nexport function getOptimizedTags(messages: Message[]): string[] {\n    // Detect language: simple check for Cyrillic\n    const hasCyrillic = messages.some(m => /[\u0430-\u044f\u0410-\u042f]/.test(m.content));\n    const lang = hasCyrillic ? 'bg' : 'en';\n\n    const config = LANGUAGES[lang];\n    const stemmer = stemmers[lang];\n    const scores: Record<string, { points: number; count: number; original: string }> = {};\n\n    messages.forEach((msg, index) => {\n        if (msg.role === 'system') return; // \u0418\u0433\u043d\u043e\u0440\u0438\u0440\u0430\u043d\u0435 \u043d\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u0438 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438\n\n        // \u041f\u0440\u0435\u043c\u0430\u0445\u0432\u0430\u043d\u0435 \u043d\u0430 \u043a\u043e\u0434 \u0431\u043b\u043e\u043a\u043e\u0432\u0435 (\u0448\u0443\u043c)\n        const cleanContent = msg.content.replace(/```[\\s\\S]*?```/g, '');\n        const words = cleanContent.match(config.regex);\n        if (!words) return;\n\n        const isAnchor = index < 2 || index === messages.length - 1;\n        const multiplier = msg.role === 'user' ? 3 : 1;\n        const anchorBonus = isAnchor ? 5 : 0;\n\n        words.forEach(word => {\n            const lowerWord = word.toLowerCase();\n            if (lowerWord.length < 4) return;\n\n            const stem = stemmer(lowerWord);\n            \n            // O(1) \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0432 Whitelist (\u0442\u044a\u0440\u0441\u0438\u043c \u0438\u043b\u0438 \u0446\u044f\u043b\u0430\u0442\u0430 \u0434\u0443\u043c\u0430, \u0438\u043b\u0438 \u043a\u043e\u0440\u0435\u043d\u0430)\n            const matchedBase = config.whitelist[lowerWord] ? lowerWord : (config.whitelist[stem] ? stem : null);\n\n            if (matchedBase) {\n                if (!scores[matchedBase]) {\n                    scores[matchedBase] = { points: 0, count: 0, original: lowerWord };\n                }\n                scores[matchedBase].points += (multiplier + anchorBonus);\n                scores[matchedBase].count += 1;\n            }\n        });\n    });\n\n    return Object.values(scores)\n        .map(s => ({\n            tag: s.original,\n            finalScore: s.points * Math.log1p(s.count) // Normalization\n        }))\n        .sort((a, b) => b.finalScore - a.finalScore)\n        .slice(0, 3)\n        .map(s => s.tag);\n}\n\n// --- End Tag Generation Logic ---\n\nconst API_BASE_URL = CONFIG.API_BASE_URL;\nconst DASHBOARD_URL = CONFIG.DASHBOARD_URL;\ndebugLog(`Using API_BASE_URL: ${API_BASE_URL}`);\n\n/**\n * Get user folders from Dashboard (Stale-While-Revalidate)\n */\nexport async function getUserFolders(silent: boolean = false) {\n    // 1. Try to get from cache first\n    const cached = await CacheManager.getFolders();\n    \n    // 2. Define the background refresh logic\n    const fetchFromServer = async () => {\n        const { accessToken } = await chrome.storage.local.get(['accessToken']);\n        if (!accessToken) {\n            if (!silent) chrome.tabs.create({ url: `${DASHBOARD_URL}/auth/signin?redirect=/extension-auth` });\n            throw new Error('No access token');\n        }\n\n        const response = await fetchWithGuard(`${API_BASE_URL}/api/folders`, {\n            headers: { 'Authorization': `Bearer ${accessToken}` }\n        });\n\n        if (!response.ok) {\n            if (response.status === 401) throw new Error('Unauthorized');\n            throw new Error('Failed to fetch folders');\n        }\n\n        const data = await response.json();\n        const folders = data.folders || [];\n        await CacheManager.setFolders(folders);\n        return folders;\n    };\n\n    // 3. Return cached data immediately if available, then refresh in background\n    if (cached) {\n        fetchFromServer().catch(err => logger.warn('DashboardAPI', 'Background folder refresh failed', err));\n        return cached;\n    }\n\n    // 4. If no cache, wait for the first fetch\n    return await fetchFromServer();\n}\n\n/**\n * Get user settings from Dashboard (Stale-While-Revalidate)\n */\nexport async function getUserSettings() {\n    // 1. Try cache\n    const cached = await CacheManager.getSettings();\n\n    const fetchFromServer = async () => {\n        const { accessToken } = await chrome.storage.local.get(['accessToken']);\n        if (!accessToken) return { quickAccessFolders: [] };\n\n        const response = await fetchWithGuard(`${API_BASE_URL}/api/user/settings`, {\n            headers: { 'Authorization': `Bearer ${accessToken}` }\n        });\n\n        if (!response.ok) return { quickAccessFolders: [] };\n\n        const data = await response.json();\n        const settings = data.settings || { quickAccessFolders: [] };\n        await CacheManager.setSettings(settings);\n        return settings;\n    };\n\n    if (cached) {\n        fetchFromServer().catch(err => logger.warn('DashboardAPI', 'Background settings refresh failed:', err));\n        return cached;\n    }\n\n    return await fetchFromServer();\n}\n\n/**\n * Save conversation to Dashboard\n */\nexport async function saveToDashboard(conversationData: Conversation, folderId: string | null, silent: boolean) {\n    const { accessToken, expiresAt } = await chrome.storage.local.get(['accessToken', 'expiresAt']);\n\n    const isTokenValid = accessToken && (!expiresAt || expiresAt > Date.now());\n\n    if (!isTokenValid) {\n        logger.warn('DashboardAPI', '\u26a0\ufe0f Invalid or expired token');\n        if (!silent) chrome.tabs.create({ url: `${DASHBOARD_URL}/auth/signin?redirect=/extension-auth` });\n        throw new Error('Please authenticate first');\n    }\n\n    const API_URL = `${API_BASE_URL}/api/chats`;\n    logger.info('DashboardAPI', `\ud83d\udce4 Saving chat...`);\n\n    return await limiters.dashboard.schedule(async () => {\n        const formattedContent = formatMessagesAsText(conversationData);\n        const chatUrl = conversationData.url || `https://${conversationData.platform}/${conversationData.id}`;\n        const localTags = getOptimizedTags(conversationData.messages || []);\n\n        const requestBody: CreateChatInput = {\n            title: conversationData.title || 'Untitled Chat',\n            content: formattedContent,\n            messages: conversationData.messages as any[] || [],\n            platform: conversationData.platform,\n            url: chatUrl,\n            folder_id: folderId || null,\n            tags: localTags\n        };\n\n        // 1. Check if we should even try (offline check)\n        if (typeof navigator !== 'undefined' && !navigator.onLine) {\n            debugLog('\ud83d\udcf6 Offline detected. Queuing chat.');\n            await SyncManager.addToQueue('chat', { ...requestBody, folderId }); \n            throw new Error('Offline: Saved to sync queue');\n        }\n\n        try {\n            const response = await fetchWithGuard(`${API_BASE_URL}/api/chats`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${accessToken}`\n                },\n                body: JSON.stringify(requestBody)\n            });\n\n            if (response.status === 401) {\n                await chrome.storage.local.remove(['accessToken']);\n                if (!silent) chrome.tabs.create({ url: `${DASHBOARD_URL}/auth/signin?redirect=/extension-auth` });\n                throw new Error('Session expired');\n            }\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                // Queue on generic server errors (5xx)\n                if (response.status >= 500) {\n                    logger.warn('DashboardAPI', '\u26a0\ufe0f Server error. Queuing for retry.');\n                    await SyncManager.addToQueue('chat', { ...requestBody, folderId });\n                }\n                throw new Error(errorText);\n            }\n            \n            const result = await response.json();\n            logger.info('DashboardAPI', '\u2705 Save successful');\n\n            // \ud83d\ude80 Trigger background sync of any previously queued items\n            SyncManager.processQueue(async (item) => {\n                try {\n                    const syncResponse = await fetch(`${API_BASE_URL}/api/chats`, {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json',\n                            'Authorization': `Bearer ${accessToken}`\n                        },\n                        body: JSON.stringify(item.data)\n                    });\n                    return syncResponse.ok;\n                } catch {\n                    return false;\n                }\n            }).catch(err => logger.error('DashboardAPI', 'Queue processing failed:', err));\n\n            return result;\n        } catch (error: any) {\n            // Queue on network errors (fetch failed)\n            if (error instanceof TypeError && error.message.includes('fetch')) {\n                logger.warn('DashboardAPI', '\ud83d\udcf6 Network error. Queuing chat.');\n                await SyncManager.addToQueue('chat', { ...requestBody, folderId });\n                throw new Error('Network error: Saved to sync queue');\n            }\n            throw error;\n        }\n    });\n}\n\n/**\n * Format messages as text for storage\n */\nfunction formatMessagesAsText(conversationData: Conversation): string {\n    if (!conversationData.messages?.length) return 'No messages';\n    return conversationData.messages\n        .map((m) => `[${m.role?.toUpperCase()}]: ${m.content}`)\n        .join('\\n\\n');\n}\n\n/**\n * Enhance prompt using Centralized AI Gateway\n * Uses the 'internal-enhancer' alias defined in models.json\n */\nexport async function enhancePrompt(promptText: string) {\n    const { accessToken } = await chrome.storage.local.get(['accessToken']);\n    \n    const response = await fetchWithGuard(`${API_BASE_URL}/api/ai/enhance`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': accessToken ? `Bearer ${accessToken}` : ''\n        },\n        body: JSON.stringify({ \n            prompt: promptText,\n            model_alias: 'internal-enhancer' \n        })\n    });\n\n    if (!response.ok) {\n        throw new Error('Failed to enhance prompt via gateway');\n    }\n\n    const data = await response.json();\n    return data.enhancedPrompt;\n}\n",
  "apps/extension/src/background/modules/tabManager.ts": "import { logger } from '@/lib/logger';\n\nexport class TabManager {\n    private DEBUG_MODE: boolean;\n\n    constructor(debug = false) {\n        this.DEBUG_MODE = debug;\n        \n        this.handleTabUpdated = this.handleTabUpdated.bind(this);\n        this.handleTabActivated = this.handleTabActivated.bind(this);\n        this.handleTabRemoved = this.handleTabRemoved.bind(this);\n    }\n\n    initialize() {\n        chrome.tabs.onUpdated.addListener(this.handleTabUpdated);\n        chrome.tabs.onActivated.addListener(this.handleTabActivated);\n        chrome.tabs.onRemoved.addListener(this.handleTabRemoved);\n        \n        logger.info('TabManager', '\ud83d\udcd1 Tab listeners registered');\n    }\n\n    private handleTabUpdated(\n        tabId: number,\n        changeInfo: chrome.tabs.TabChangeInfo,\n        tab: chrome.tabs.Tab\n    ) {\n        // Only act on complete page loads\n        if (changeInfo.status !== 'complete') return;\n        if (!tab.url) return;\n\n        // Example: Inject scripts on specific platforms\n        if (tab.url.includes('gemini.google.com')) {\n            if (this.DEBUG_MODE) {\n                logger.debug('TabManager', 'Gemini detected:', tabId);\n            }\n            // Auto-inject logic here (optional)\n        }\n    }\n\n    private handleTabActivated(activeInfo: chrome.tabs.TabActiveInfo) {\n        // Example: Update badge when switching tabs\n        if (this.DEBUG_MODE) {\n            logger.debug('TabManager', 'Tab activated:', activeInfo.tabId);\n        }\n    }\n\n    private handleTabRemoved(tabId: number, removeInfo: chrome.tabs.TabRemoveInfo) {\n        // Cleanup logic\n        if (this.DEBUG_MODE) {\n            logger.debug('TabManager', 'Tab closed:', tabId);\n        }\n    }\n}\n",
  "apps/extension/src/background/modules/networkObserver.ts": "import { logger } from '@/lib/logger';\n\nexport class NetworkObserver {\n    private DEBUG_MODE: boolean;\n\n    constructor(debug = false) {\n        this.DEBUG_MODE = debug;\n        this.handleClaudeRequest = this.handleClaudeRequest.bind(this);\n    }\n\n    initialize() {\n        try {\n            if (!chrome.webRequest?.onBeforeRequest) {\n                logger.warn('NetworkObserver', '\u26a0\ufe0f chrome.webRequest API not available');\n                return;\n            }\n\n            chrome.webRequest.onBeforeRequest.addListener(\n                this.handleClaudeRequest,\n                { urls: [\"https://claude.ai/api/organizations/*\"] }\n            );\n\n            logger.info('NetworkObserver', '\ud83d\udd75\ufe0f Listening for Claude org_id...');\n        } catch (e) {\n            logger.error('NetworkObserver', '\u274c Setup failed:', e);\n        }\n    }\n\n    private handleClaudeRequest(details: chrome.webRequest.WebRequestBodyDetails) {\n        try {\n            const match = details.url.match(/organizations\\/([a-f0-9-]+)/i);\n            if (!match?.[1]) return;\n\n            const orgId = match[1];\n\n            // Avoid excessive writes\n            chrome.storage.local.get(['claude_org_id'], (result) => {\n                if (result.claude_org_id !== orgId) {\n                    if (this.DEBUG_MODE) {\n                        logger.debug('NetworkObserver', '\ud83c\udfaf Captured Claude Org ID:', orgId);\n                    }\n                    chrome.storage.local.set({ claude_org_id: orgId });\n                }\n            });\n        } catch (e) {\n            // Silent fail\n        }\n    }\n}\n",
  "apps/extension/src/background/modules/cacheManager.ts": "/**\n * CacheManager\n * \n * Handles local caching of dashboard data (folders, settings)\n * to ensure immediate UI responsiveness in the popup.\n * Uses Stale-While-Revalidate pattern.\n */\n\nexport const CACHE_KEYS = {\n    FOLDERS: 'brainbox_folders_cache',\n    SETTINGS: 'brainbox_user_settings_cache',\n    LAST_SYNC: 'brainbox_last_sync_timestamp'\n};\n\nexport class CacheManager {\n    /**\n     * Get cached folders\n     */\n    static async getFolders(): Promise<any[] | null> {\n        const result = await chrome.storage.local.get([CACHE_KEYS.FOLDERS]);\n        return result[CACHE_KEYS.FOLDERS] || null;\n    }\n\n    /**\n     * Set cached folders\n     */\n    static async setFolders(folders: any[]): Promise<void> {\n        await chrome.storage.local.set({ \n            [CACHE_KEYS.FOLDERS]: folders,\n            [CACHE_KEYS.LAST_SYNC]: Date.now()\n        });\n    }\n\n    /**\n     * Get cached user settings\n     */\n    static async getSettings(): Promise<any | null> {\n        const result = await chrome.storage.local.get([CACHE_KEYS.SETTINGS]);\n        return result[CACHE_KEYS.SETTINGS] || null;\n    }\n\n    /**\n     * Set cached user settings\n     */\n    static async setSettings(settings: any): Promise<void> {\n        await chrome.storage.local.set({ \n            [CACHE_KEYS.SETTINGS]: settings,\n            [CACHE_KEYS.LAST_SYNC]: Date.now()\n        });\n    }\n\n    /**\n     * Clear all caches\n     */\n    static async clearAll(): Promise<void> {\n        await chrome.storage.local.remove([\n            CACHE_KEYS.FOLDERS,\n            CACHE_KEYS.SETTINGS,\n            CACHE_KEYS.LAST_SYNC\n        ]);\n    }\n}\n",
  "apps/extension/src/background/modules/syncManager.ts": "import { logger } from '@/lib/logger';\n\n/**\n * SyncManager\n * \n * Manages a persistent queue of items to be synchronized with the Dashboard.\n * Useful for offline support and retrying failed requests.\n */\n\nexport interface SyncItem {\n    id: string;\n    type: 'chat';\n    data: any;\n    timestamp: number;\n    retries: number;\n}\n\nconst QUEUE_KEY = 'brainbox_sync_queue';\n\nexport class SyncManager {\n    /**\n     * Get all items in the sync queue\n     */\n    static async getQueue(): Promise<SyncItem[]> {\n        const result = await chrome.storage.local.get([QUEUE_KEY]);\n        return result[QUEUE_KEY] || [];\n    }\n\n    /**\n     * Add an item to the sync queue\n     */\n    static async addToQueue(type: 'chat', data: any): Promise<void> {\n        const queue = await this.getQueue();\n        const newItem: SyncItem = {\n            id: crypto.randomUUID(),\n            type,\n            data,\n            timestamp: Date.now(),\n            retries: 0\n        };\n        queue.push(newItem);\n        await chrome.storage.local.set({ [QUEUE_KEY]: queue });\n        logger.info('SyncManager', `\ud83d\udce5 Added ${type} to sync queue. Items in queue: ${queue.length}`);\n    }\n\n    /**\n     * Remove an item from the queue by ID\n     */\n    static async removeFromQueue(id: string): Promise<void> {\n        const queue = await this.getQueue();\n        const updated = queue.filter(item => item.id !== id);\n        await chrome.storage.local.set({ [QUEUE_KEY]: updated });\n    }\n\n    /**\n     * Clear the entire queue\n     */\n    static async clearQueue(): Promise<void> {\n        await chrome.storage.local.remove([QUEUE_KEY]);\n    }\n\n    /**\n     * Process the queue (attempt to sync all items)\n     * This should be called when the extension comes back online\n     */\n    static async processQueue(syncFn: (item: SyncItem) => Promise<boolean>): Promise<void> {\n        const queue = await this.getQueue();\n        if (queue.length === 0) return;\n\n        logger.info('SyncManager', `\ud83d\udd04 Processing sync queue (${queue.length} items)...`);\n\n        for (const item of queue) {\n            try {\n                const success = await syncFn(item);\n                if (success) {\n                    await this.removeFromQueue(item.id);\n                    logger.info('SyncManager', `\u2705 Successfully synced item: ${item.id}`);\n                } else {\n                    item.retries++;\n                    if (item.retries > 5) {\n                        logger.warn('SyncManager', `\u26a0\ufe0f Item ${item.id} exceeded max retries. Dropping.`);\n                        await this.removeFromQueue(item.id);\n                    } else {\n                        // Update retry count in storage\n                        const currentQueue = await this.getQueue();\n                        const target = currentQueue.find(qi => qi.id === item.id);\n                        if (target) {\n                            target.retries = item.retries;\n                            await chrome.storage.local.set({ [QUEUE_KEY]: currentQueue });\n                        }\n                    }\n                }\n            } catch (error) {\n                logger.error('SyncManager', `\u274c Failed to process item ${item.id}:`, error);\n            }\n        }\n    }\n\n    /**\n     * Initialize periodic sync or startup sync\n     */\n    static async initialize(accessToken: string | null) {\n        if (!accessToken) return;\n        \n        // Initial sync on startup\n        this.processQueue(async (item) => {\n            const { CONFIG } = await import('@/lib/config');\n            try {\n                const response = await fetch(`${CONFIG.API_BASE_URL}/api/chats`, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': `Bearer ${accessToken}`\n                    },\n                    body: JSON.stringify(item.data)\n                });\n                return response.ok;\n            } catch {\n                return false;\n            }\n        }).catch(err => logger.error('SyncManager', 'Startup sync failed:', err));\n\n        // Schedule periodic sync\n        this.scheduleSync();\n    }\n\n    /**\n     * Schedule periodic background sync using Alarms API\n     */\n    static scheduleSync() {\n        const ALARM_NAME = 'brainbox_bg_sync';\n        \n        chrome.alarms.get(ALARM_NAME, (alarm) => {\n            if (!alarm) {\n                chrome.alarms.create(ALARM_NAME, {\n                    periodInMinutes: 5,\n                    delayInMinutes: 1\n                });\n                logger.info('SyncManager', `\u23f0 Alarm '${ALARM_NAME}' created (5m interval)`);\n            }\n        });\n\n        // Listen for alarms\n        chrome.alarms.onAlarm.addListener((alarm) => {\n            if (alarm.name === ALARM_NAME) {\n                logger.info('SyncManager', `\u23f0 Alarm triggered. Processing queue...`);\n                chrome.storage.local.get(['accessToken'], ({ accessToken }) => {\n                    if (accessToken) {\n                        this.processQueue(async (item) => {\n                            const { CONFIG } = await import('@/lib/config');\n                            try {\n                                const response = await fetch(`${CONFIG.API_BASE_URL}/api/chats`, {\n                                    method: 'POST',\n                                    headers: {\n                                        'Content-Type': 'application/json',\n                                        'Authorization': `Bearer ${accessToken}`\n                                    },\n                                    body: JSON.stringify(item.data)\n                                });\n                                return response.ok;\n                            } catch {\n                                return false;\n                            }\n                        }).catch(err => logger.error('SyncManager', 'Alarm sync failed:', err));\n                    }\n                });\n            }\n        });\n    }\n}\n",
  "apps/extension/src/background/modules/installationManager.ts": "import { logger } from '@/lib/logger';\n\nexport class InstallationManager {\n    private DEBUG_MODE: boolean;\n\n    constructor(debug = false) {\n        this.DEBUG_MODE = debug;\n        this.handleInstalled = this.handleInstalled.bind(this);\n    }\n\n    initialize() {\n        chrome.runtime.onInstalled.addListener(this.handleInstalled);\n        logger.info('InstallationManager', '\ud83c\udfac Listening for lifecycle events...');\n    }\n\n    private handleInstalled(details: chrome.runtime.InstalledDetails) {\n        if (this.DEBUG_MODE) {\n            logger.debug('InstallationManager', 'Event:', details.reason);\n        }\n\n        switch (details.reason) {\n            case 'install':\n                this.onFirstInstall();\n                break;\n            \n            case 'update':\n                this.onUpdate(details.previousVersion);\n                break;\n            \n            case 'chrome_update':\n            case 'shared_module_update':\n                // Ignore browser updates\n                break;\n        }\n    }\n\n    private onFirstInstall() {\n        logger.info('InstallationManager', '\ud83c\udf89 First install detected');\n        \n        // Open welcome page\n        chrome.tabs.create({ \n            url: chrome.runtime.getURL('welcome.html') \n        });\n    }\n\n    private onUpdate(previousVersion?: string) {\n        logger.info('InstallationManager', `\ud83d\udd04 Updated from: ${previousVersion}`);\n        \n        // Migration logic here\n        // Example: Clean up old storage keys\n        // chrome.storage.local.remove(['deprecated_key']);\n    }\n}\n",
  "apps/extension/src/background/modules/authManager.ts": "import { logger } from '@/lib/logger';\n\n/**\n * AuthManager\n * \n * Responsible for:\n * 1. Listening to network requests to capture tokens (ChatGPT, Gemini).\n * 2. Managing auth state in chrome.storage.local.\n * 3. Validating Dashboard sessions.\n */\nexport class AuthManager {\n    private tokens: {\n        chatgpt: string | null;\n        gemini_at: string | null;\n        gemini_key: string | null;\n        claude_session: string | null;\n        claude_org_id: string | null;\n        \n        // New platforms\n        deepseek: string | null;\n        deepseek_version: string | null;\n        perplexity_session: string | null;\n        grok_csrf: string | null;\n        grok_auth: string | null;\n        qwen_xsrf: string | null;\n        qwen_app_id: string | null;\n        lmarena_session: string | null;\n        lmarena_fn_index: string | null;\n    };\n\n    constructor() {\n        this.tokens = {\n            chatgpt: null,\n            gemini_at: null,\n            gemini_key: null,\n            claude_session: null,\n            claude_org_id: null,\n            \n            deepseek: null,\n            deepseek_version: null,\n            perplexity_session: null,\n            grok_csrf: null,\n            grok_auth: null,\n            qwen_xsrf: null,\n            qwen_app_id: null,\n            lmarena_session: null,\n            lmarena_fn_index: null\n        };\n        \n        // Bind methods to ensure 'this' context\n        this.handleChatGPTHeaders = this.handleChatGPTHeaders.bind(this);\n        this.handleClaudeRequest = this.handleClaudeRequest.bind(this);\n        this.handleGeminiRequest = this.handleGeminiRequest.bind(this);\n        \n        // New Platform Handlers\n        this.handleDeepSeekHeaders = this.handleDeepSeekHeaders.bind(this);\n        this.handlePerplexityHeaders = this.handlePerplexityHeaders.bind(this);\n        this.handleGrokHeaders = this.handleGrokHeaders.bind(this);\n        this.handleQwenHeaders = this.handleQwenHeaders.bind(this);\n    }\n\n    /**\n     * Start listening for tokens\n     */\n    initialize() {\n        this.registerListeners();\n        this.loadTokensFromStorage();\n        logger.info('AuthManager', '\ud83d\udee1\ufe0f Initialized and listening.');\n    }\n\n    registerListeners() {\n        // --- ChatGPT ---\n        chrome.webRequest.onBeforeSendHeaders.addListener(\n            this.handleChatGPTHeaders as any,\n            { urls: ['https://chatgpt.com/backend-api/*'] },\n            ['requestHeaders']\n        );\n\n        // --- Claude ---\n        chrome.webRequest.onBeforeRequest.addListener(\n            this.handleClaudeRequest as any,\n            { urls: ['https://claude.ai/api/organizations/*'] },\n            []\n        );\n\n        // --- Gemini ---\n        chrome.webRequest.onBeforeRequest.addListener(\n            this.handleGeminiRequest as any,\n            { urls: ['https://gemini.google.com/*', 'http://gemini.google.com/*'] },\n            ['requestBody']\n        );\n\n        // --- DeepSeek ---\n        chrome.webRequest.onBeforeSendHeaders.addListener(\n            this.handleDeepSeekHeaders as any,\n            { urls: ['https://chat.deepseek.com/api/*'] },\n            ['requestHeaders']\n        );\n\n        // --- Perplexity ---\n        chrome.webRequest.onBeforeSendHeaders.addListener(\n            this.handlePerplexityHeaders as any,\n            { urls: ['https://www.perplexity.ai/api/*'] },\n            ['requestHeaders']\n        );\n\n        // --- Grok ---\n        chrome.webRequest.onBeforeSendHeaders.addListener(\n            this.handleGrokHeaders as any,\n            { urls: ['https://x.com/i/api/*', 'https://grok.com/api/*'] },\n            ['requestHeaders']\n        );\n\n        // --- Qwen ---\n        chrome.webRequest.onBeforeSendHeaders.addListener(\n            this.handleQwenHeaders as any,\n            { urls: ['https://chat.qwenlm.ai/api/*'] },\n            ['requestHeaders']\n        );\n    }\n\n    async loadTokensFromStorage() {\n        const result = await chrome.storage.local.get([\n            'chatgpt_token', \n            'gemini_at_token', \n            'gemini_dynamic_key', \n            'claude_org_id',\n            'deepseek_token',\n            'deepseek_version',\n            'perplexity_session',\n            'grok_csrf_token',\n            'grok_auth_token',\n            'qwen_xsrf_token',\n            'qwen_app_id',\n            'lmarena_session_hash',\n            'lmarena_fn_index'\n        ]);\n        \n        this.tokens.chatgpt = result.chatgpt_token || null;\n        this.tokens.gemini_at = result.gemini_at_token || null;\n        this.tokens.gemini_key = result.gemini_dynamic_key || null;\n        this.tokens.claude_org_id = result.claude_org_id || null;\n        this.tokens.deepseek = result.deepseek_token || null;\n        this.tokens.deepseek_version = result.deepseek_version || null;\n        this.tokens.perplexity_session = result.perplexity_session || null;\n        this.tokens.grok_csrf = result.grok_csrf_token || null;\n        this.tokens.grok_auth = result.grok_auth_token || null;\n        this.tokens.qwen_xsrf = result.qwen_xsrf_token || null;\n        this.tokens.qwen_app_id = result.qwen_app_id || null;\n        this.tokens.lmarena_session = result.lmarena_session_hash || null;\n        this.tokens.lmarena_fn_index = result.lmarena_fn_index || null;\n    }\n\n    // ========================================================================\n    // Handlers\n    // ========================================================================\n\n    handleChatGPTHeaders(details: any) {\n        const authHeader = details.requestHeaders?.find(\n            (h: any) => h.name.toLowerCase() === 'authorization'\n        );\n\n        if (authHeader && authHeader.value?.startsWith('Bearer ')) {\n            const token = authHeader.value;\n            if (this.tokens.chatgpt !== token) {\n                this.tokens.chatgpt = token;\n                chrome.storage.local.set({ chatgpt_token: token });\n                logger.debug('AuthManager', '\u2705 ChatGPT token updated');\n            }\n        }\n    }\n\n    handleClaudeRequest(details: any) {\n        if (details.url.includes('/api/organizations/')) {\n            try {\n                // Pattern: \"/api/organizations/([^/]+)/\"\n                const match = details.url.match(/\\/api\\/organizations\\/([^\\/]+)\\//);\n                if (match && match[1]) {\n                    const orgId = match[1];\n                    if (this.tokens.claude_org_id !== orgId) {\n                        this.tokens.claude_org_id = orgId;\n                        chrome.storage.local.set({\n                            claude_org_id: orgId,\n                            org_id_discovered_at: Date.now()\n                        });\n                        logger.debug('AuthManager', '\u2705 Claude Org ID updated', orgId);\n                    }\n                }\n            } catch (error) {\n                logger.error('AuthManager', '\u274c Claude extraction error', error);\n            }\n        }\n    }\n\n    handleGeminiRequest(details: any) {\n        // Implementation from service-worker.js\n        \n        // 1. Capture AT Token from URL\n        if (details.url.includes('/app/')) {\n            try {\n                const url = new URL(details.url);\n                const pathParts = url.pathname.split('/');\n                const atToken = pathParts[pathParts.length - 1];\n                if (atToken && atToken.startsWith('AT-')) {\n                    if (this.tokens.gemini_at !== atToken) {\n                        this.tokens.gemini_at = atToken;\n                        chrome.storage.local.set({ gemini_at_token: atToken });\n                        logger.debug('AuthManager', '\u2705 Gemini AT Token updated');\n                    }\n                }\n            } catch (e) {\n                // ignore URL parsing errors\n            }\n        }\n\n        // 2. Capture Dynamic Key from batchexecute\n        if (!details.url.includes('batchexecute') || !details.requestBody) return;\n\n        try {\n            const formData = details.requestBody.formData;\n            if (formData && formData['f.req']) {\n                const reqData = formData['f.req'][0];\n                \n                // Spec Pattern: /\"([a-zA-Z0-9]{5,6})\",\\s*\"\\[/\n                const specPattern = /\"([a-zA-Z0-9]{5,6})\",\\s*\"\\[/;\n                const match = reqData.match(specPattern);\n\n                if (match) {\n                    const key = match[1];\n                    if (this.tokens.gemini_key !== key) {\n                        this.tokens.gemini_key = key;\n                        chrome.storage.local.set({\n                            gemini_dynamic_key: key,\n                            key_discovered_at: Date.now()\n                        });\n                        logger.debug('AuthManager', '\u2705 Gemini Dynamic Key updated');\n                    }\n                }\n            }\n        } catch (error) {\n            logger.error('AuthManager', '\u274c Gemini extraction error', error);\n        }\n    }\n    /**\n     * Generic dispatcher for platform headers (Grok, Perplexity, DeepSeek, Qwen)\n     */\n    handlePlatformHeaders(details: any) {\n        if (details.url.includes('deepseek.com')) {\n            this.handleDeepSeekHeaders(details);\n        } else if (details.url.includes('perplexity.ai')) {\n            this.handlePerplexityHeaders(details);\n        } else if (details.url.includes('x.com') || details.url.includes('grok.com')) {\n            this.handleGrokHeaders(details);\n        } else if (details.url.includes('qwenlm.ai')) {\n            this.handleQwenHeaders(details);\n        }\n    }\n\n\n    handleDeepSeekHeaders(details: any) {\n        const authHeader = details.requestHeaders?.find(\n            (h: any) => h.name.toLowerCase() === 'authorization'\n        );\n\n        if (authHeader && authHeader.value?.startsWith('Bearer ')) {\n            const token = authHeader.value;\n            if (this.tokens.deepseek !== token) {\n                this.tokens.deepseek = token;\n                chrome.storage.local.set({ deepseek_token: token });\n                logger.debug('AuthManager', '\u2705 DeepSeek token updated');\n            }\n        }\n\n        const dsVersionHeader = details.requestHeaders?.find((h: any) => h.name.toLowerCase() === 'x-client-version');\n        if (dsVersionHeader && details.url.includes('deepseek.com')) {\n            if (this.tokens.deepseek_version !== dsVersionHeader.value) {\n                this.tokens.deepseek_version = dsVersionHeader.value;\n                chrome.storage.local.set({ deepseek_version: dsVersionHeader.value });\n                logger.debug('AuthManager', '\u2705 DeepSeek version header updated');\n            }\n        }\n    }\n\n    handlePerplexityHeaders(details: any) {\n        const authHeader = details.requestHeaders?.find(\n            (h: any) => h.name.toLowerCase() === 'authorization'\n        );\n\n        if (authHeader && authHeader.value?.startsWith('Bearer ')) {\n            const token = authHeader.value;\n            if (this.tokens.perplexity_session !== token) {\n                this.tokens.perplexity_session = token;\n                chrome.storage.local.set({ perplexity_session: token });\n                logger.debug('AuthManager', '\u2705 Perplexity token updated');\n            }\n        }\n\n        // Capture session cookies specifically for Perplexity (web API fallback)\n        const cookieHeader = details.requestHeaders?.find((h: any) => h.name.toLowerCase() === 'cookie');\n        if (cookieHeader && details.url.includes('perplexity.ai') && !authHeader) {\n            if (this.tokens.perplexity_session !== cookieHeader.value) {\n                this.tokens.perplexity_session = cookieHeader.value;\n                chrome.storage.local.set({ perplexity_session: cookieHeader.value });\n                logger.debug('AuthManager', '\u2705 Perplexity session cookie captured');\n            }\n        }\n    }\n\n    handleGrokHeaders(details: any) {\n        const csrfHeader = details.requestHeaders?.find(\n            (h: any) => h.name.toLowerCase() === 'x-csrf-token'\n        );\n        const authHeader = details.requestHeaders?.find(\n            (h: any) => h.name.toLowerCase() === 'authorization'\n        );\n\n        let updated = false;\n\n        if (csrfHeader && this.tokens.grok_csrf !== csrfHeader.value) {\n            this.tokens.grok_csrf = csrfHeader.value;\n            chrome.storage.local.set({ grok_csrf_token: csrfHeader.value });\n            updated = true;\n        }\n\n        if (authHeader && this.tokens.grok_auth !== authHeader.value) {\n            this.tokens.grok_auth = authHeader.value;\n            chrome.storage.local.set({ grok_auth_token: authHeader.value });\n            updated = true;\n        }\n\n        if (updated) {\n            logger.debug('AuthManager', '\u2705 Grok tokens updated');\n        }\n    }\n\n    handleQwenHeaders(details: any) {\n        const xsrfHeader = details.requestHeaders?.find(\n            (h: any) => h.name.toLowerCase() === 'x-xsrf-token'\n        );\n        const appIdHeader = details.requestHeaders?.find(\n            (h: any) => h.name.toLowerCase() === 'x-app-id'\n        );\n\n        let updated = false;\n\n        if (xsrfHeader && this.tokens.qwen_xsrf !== xsrfHeader.value) {\n            this.tokens.qwen_xsrf = xsrfHeader.value;\n            chrome.storage.local.set({ qwen_xsrf_token: xsrfHeader.value });\n            updated = true;\n        }\n\n        if (appIdHeader && this.tokens.qwen_app_id !== appIdHeader.value) {\n            this.tokens.qwen_app_id = appIdHeader.value;\n            chrome.storage.local.set({ qwen_app_id: appIdHeader.value });\n            updated = true;\n        }\n\n        if (updated) {\n            logger.debug('AuthManager', '\u2705 Qwen tokens updated');\n        }\n    }\n\n    // ========================================================================\n    // Public API\n    // ========================================================================\n\n    async setDashboardSession(session: any) {\n        await chrome.storage.local.set({\n            accessToken: session.accessToken,\n            refreshToken: session.refreshToken,\n            expiresAt: session.expiresAt,\n            rememberMe: session.rememberMe\n        });\n        logger.debug('AuthManager', '\u2705 Dashboard session updated');\n    }\n\n    async isSessionValid() {\n        const { accessToken, expiresAt } = await chrome.storage.local.get(['accessToken', 'expiresAt']);\n        const isValid = accessToken && (!expiresAt || expiresAt > Date.now());\n        return !!isValid;\n    }\n\n    /**\n     * Actively sync and verify all tokens\n     */\n    async syncAll() {\n        logger.debug('AuthManager', '\ud83d\udd04 Starting full token sync...');\n        \n        // 1. Refresh internal state from storage\n        await this.loadTokensFromStorage();\n        \n        // 2. Verify Dashboard Session via Ping\n        const { accessToken } = await chrome.storage.local.get(['accessToken']);\n        if (!accessToken) return { isValid: false, tokens: this.tokens };\n\n        try {\n            // Using a simple fetch to verify token validity\n            const { CONFIG } = await import('@/lib/config');\n            const response = await fetch(`${CONFIG.API_BASE_URL}/api/folders`, {\n                headers: { 'Authorization': `Bearer ${accessToken}` }\n            });\n            \n            if (response && response.status === 401) {\n                // Token is dead, cleanup\n                await chrome.storage.local.remove(['accessToken', 'refreshToken', 'userEmail', 'expiresAt']);\n                return { isValid: false, tokens: this.tokens };\n            }\n            \n            return { \n                isValid: response?.ok ?? false, \n                tokens: this.tokens \n            };\n        } catch (e) {\n            logger.error('AuthManager', 'Sync ping failed', e);\n            // If offline, trust storage if not expired\n            const valid = await this.isSessionValid();\n            return { isValid: valid, tokens: this.tokens };\n        }\n    }\n\n    async getHeader(platform: any) {\n        // Return necessary headers for a platform request\n        // This abstracts token retrieval for the API handlers\n        // TODO: Implement cleaner interface for API calls\n    }\n}\n\n",
  "apps/extension/src/background/modules/dynamicMenus.ts": "/**\n * DynamicMenus\n * \n * Responsible for:\n * 1. Managing Chrome Context Menus.\n * 2. Subscribing to PromptSyncManager updates.\n * 3. Rendering a hierarchical menu structure (Tree/Grid).\n * 4. Handling menu clicks to inject prompts.\n */\nimport { PromptSyncManager } from '@brainbox/shared/logic/promptSync';\nimport { enhancePrompt } from './dashboardApi';\nimport { CONFIG } from '@/lib/config';\nimport { logger } from '@/lib/logger';\n\n// We need a way to message the tab, currently utilizing the service worker's helper or rewriting it here.\n// For now, we'll assume we can emit a message or use chrome.tabs.\n\nexport class DynamicMenus {\n    private syncManager: PromptSyncManager;\n    private DEBUG_MODE: boolean = true;\n\n    constructor(syncManager: PromptSyncManager) {\n        this.syncManager = syncManager;\n        this.handleMenuClick = this.handleMenuClick.bind(this);\n    }\n\n    initialize() {\n        // Register click handler\n        chrome.contextMenus.onClicked.addListener(this.handleMenuClick);\n        \n        // Initial build\n        this.rebuildMenus();\n        \n        // Listen for storage changes to trigger rebuild\n        chrome.storage.onChanged.addListener((changes, areaName) => {\n            if (areaName === 'local' && (changes['brainbox_prompts_cache'] || changes['brainbox_user_settings_cache'] || changes['brainbox_folders_cache'])) {\n                if (this.DEBUG_MODE) logger.debug('DynamicMenus', '\ud83d\udd04 Data updated, rebuilding menus...');\n                this.rebuildMenus();\n            }\n        });\n        \n        logger.info('DynamicMenus', '\ud83d\uddb1\ufe0f Context menus initialized.');\n    }\n\n    private isRebuilding = false;\n    private needsRebuild = false;\n\n    async rebuildMenus() {\n        if (this.isRebuilding) {\n            this.needsRebuild = true;\n            return;\n        }\n\n        this.isRebuilding = true;\n        this.needsRebuild = false;\n\n        try {\n            // Step 1: Remove ALL existing menus to ensure a clean slate\n            // Using removeAll is more efficient and reliable than individual removals\n            await new Promise<void>((resolve) => {\n                chrome.contextMenus.removeAll(() => {\n                    const error = chrome.runtime.lastError;\n                    if (error && this.DEBUG_MODE) {\n                        logger.warn('DynamicMenus', 'Context menu removal warning:', error.message);\n                    }\n                    resolve();\n                });\n            });\n\n            // ========================================================================\n            // 1. SAVE CHAT MENU (contexts: page, on AI platforms)\n            // ========================================================================\n            const saveChatId = 'brainbox_save_chat';\n            chrome.contextMenus.create({\n                id: saveChatId,\n                title: '\ud83d\udcbe Save Chat to BrainBox',\n                contexts: ['page'],\n                documentUrlPatterns: [\n                    // Original platforms\n                    'https://chatgpt.com/*',\n                    'https://chat.openai.com/*',\n                    'https://claude.ai/*',\n                    'https://gemini.google.com/*',\n                    // New platforms (2026)\n                    'https://chat.deepseek.com/*',\n                    'https://www.perplexity.ai/*',\n                    'https://*.perplexity.ai/*',\n                    'https://x.com/i/grok*',\n                    'https://grok.com/*',\n                    'https://chat.qwen.ai/*',\n                    'https://chat.lmsys.org/*',\n                    'https://arena.ai/*',\n                    'https://lmarena.ai/*'\n                ]\n            });\n\n            // ========================================================================\n            // 2. CREATE PROMPT MENU (contexts: selection, anywhere)\n            // ========================================================================\n            const createPromptId = 'brainbox_create_prompt';\n            chrome.contextMenus.create({\n                id: createPromptId,\n                title: '\ud83d\udcdd Create Prompt from Selection',\n                contexts: ['selection']\n            });\n\n            // Enhance Selection (context: selection + editable)\n            const enhanceId = 'brainbox_enhance_selection';\n            chrome.contextMenus.create({\n                id: enhanceId,\n                title: '\u2728 AI Enhance Selection',\n                contexts: ['selection', 'editable']\n            });\n\n            // ========================================================================\n            // 3. INJECT PROMPTS MENU (contexts: editable, in textareas)\n            // ========================================================================\n            const injectRootId = 'brainbox_inject_root';\n            chrome.contextMenus.create({\n                id: injectRootId,\n                title: '\ud83e\udde0 Inject Prompt',\n                contexts: ['editable']\n            });\n\n            // 1. Search Action\n            const searchId = 'brainbox_inject_search';\n            chrome.contextMenus.create({\n                id: searchId,\n                parentId: injectRootId,\n                title: '\ud83d\udd0d Search Prompts...',\n                contexts: ['editable']\n            });\n\n            chrome.contextMenus.create({\n                id: 'brainbox_inject_sep_1',\n                parentId: injectRootId,\n                type: 'separator',\n                contexts: ['editable']\n            });\n\n            // Get data from cache\n            const prompts = await this.syncManager.getAllPrompts();\n            const { brainbox_user_settings_cache: settings } = await chrome.storage.local.get(['brainbox_user_settings_cache']);\n            const { brainbox_folders_cache: folders } = await chrome.storage.local.get(['brainbox_folders_cache']);\n\n            const quickAccessFolderIds = (settings?.quickAccessFolders || []).slice(0, 3);\n            \n            // ========================================================================\n            // \ud83d\udcc2 SECTION: FOLDERS (Selected by user)\n            // ========================================================================\n            if (quickAccessFolderIds.length > 0 && folders) {\n                quickAccessFolderIds.forEach((folderId: string) => {\n                    const folder = folders.find((f: any) => f.id === folderId);\n                    if (folder) {\n                        const folderMenuId = `brainbox_folder_${folder.id}`;\n                        chrome.contextMenus.create({\n                            id: folderMenuId,\n                            parentId: injectRootId,\n                            title: `\ud83d\udcc2 ${folder.name}`,\n                            contexts: ['editable']\n                        });\n\n                        // Prompts in this folder\n                        const folderPrompts = prompts.filter(p => p.folder_id === folder.id).slice(0, 7);\n                        if (folderPrompts.length > 0) {\n                            folderPrompts.forEach(prompt => {\n                                chrome.contextMenus.create({\n                                    id: `brainbox_inject_prompt_${prompt.id}`,\n                                    parentId: folderMenuId,\n                                    title: prompt.title || 'Untitled',\n                                    contexts: ['editable']\n                                });\n                            });\n                        } else {\n                            chrome.contextMenus.create({\n                                id: `brainbox_folder_empty_${folder.id}`,\n                                parentId: folderMenuId,\n                                title: '(Empty folder)',\n                                contexts: ['editable'],\n                                enabled: false\n                            });\n                        }\n                    }\n                });\n\n                chrome.contextMenus.create({\n                    id: 'brainbox_inject_sep_2',\n                    parentId: injectRootId,\n                    type: 'separator',\n                    contexts: ['editable']\n                });\n            }\n\n\n            // ========================================================================\n            // \u26a1 SECTION: QUICK (Last 7 prompts in submenu)\n            // ========================================================================\n            const quickPrompts = [...prompts]\n                .sort((a, b) => new Date(b.updated_at || b.created_at).getTime() - new Date(a.updated_at || a.created_at).getTime())\n                .slice(0, 7);\n\n            if (quickPrompts.length > 0) {\n                // Create \"Quick\" submenu\n                const quickMenuId = 'brainbox_quick_submenu';\n                chrome.contextMenus.create({\n                    id: quickMenuId,\n                    parentId: injectRootId,\n                    title: '\u26a1 Quick',\n                    contexts: ['editable']\n                });\n\n                // Add prompts inside \"Quick\" submenu\n                quickPrompts.forEach(prompt => {\n                    chrome.contextMenus.create({\n                        id: `brainbox_inject_prompt_quick_${prompt.id}`,\n                        parentId: quickMenuId, // Inside Quick submenu\n                        title: prompt.title || 'Untitled',\n                        contexts: ['editable']\n                    });\n                });\n            } else if (!prompts || prompts.length === 0) {\n                chrome.contextMenus.create({\n                    id: 'brainbox_inject_empty',\n                    parentId: injectRootId,\n                    title: '(No prompts synced)',\n                    contexts: ['editable'],\n                    enabled: false\n                });\n            }\n\n\n            if (this.DEBUG_MODE) logger.info('DynamicMenus', '\u2705 All context menus created');\n\n        } catch (error) {\n            logger.error('DynamicMenus', '\u274c Failed to rebuild menus:', error);\n        } finally {\n            this.isRebuilding = false;\n            // If another request came in while we were busy, rebuild again\n            if (this.needsRebuild) {\n                this.rebuildMenus();\n            }\n        }\n    }\n\n\n    async handleMenuClick(info: chrome.contextMenus.OnClickData, tab?: chrome.tabs.Tab) {\n        if (!tab || !tab.id) return;\n\n        // Check login state for protected actions\n        const protectedActions = ['brainbox_save_chat', 'brainbox_create_prompt', 'brainbox_enhance_selection', 'brainbox_inject_search'];\n        const isProtected = protectedActions.includes(info.menuItemId as string) || \n                           (typeof info.menuItemId === 'string' && info.menuItemId.startsWith('brainbox_inject_prompt_'));\n\n        if (isProtected) {\n            const { accessToken } = await chrome.storage.local.get(['accessToken']);\n            if (!accessToken) {\n                if (this.DEBUG_MODE) logger.warn('DynamicMenus', '\u26d4 User not logged in, redirecting...');\n                chrome.tabs.create({ url: `${CONFIG.DASHBOARD_URL}/auth/signin?redirect=/extension-auth` });\n                return;\n            }\n        }\n\n        // ========================================================================\n        // SAVE CHAT - Trigger save flow in content script\n        // ========================================================================\n        if (info.menuItemId === 'brainbox_save_chat') {\n            chrome.tabs.sendMessage(tab.id, { action: 'triggerSaveChat' }).catch(err => {\n                logger.error('DynamicMenus', '\u274c Save chat failed:', err);\n            });\n            return;\n        }\n\n        // ========================================================================\n        // CREATE PROMPT - Open dialog with selected text\n        // ========================================================================\n        if (info.menuItemId === 'brainbox_create_prompt') {\n            chrome.tabs.sendMessage(tab.id, { \n                action: 'openCreatePromptDialog',\n                selectedText: info.selectionText \n            }).catch(err => {\n                logger.error('DynamicMenus', '\u274c Create prompt failed:', err);\n            });\n            return;\n        }\n\n        // ========================================================================\n        // ENHANCE SELECTION - Improve text using AI\n        // ========================================================================\n        if (info.menuItemId === 'brainbox_enhance_selection') {\n            const selectedText = info.selectionText;\n            if (!selectedText) return;\n\n            try {\n                // Show loading toast in the active tab\n                chrome.tabs.sendMessage(tab.id, { \n                    action: 'showNotification', \n                    message: '\u2728 Enhancing selection...', \n                    type: 'info',\n                    duration: 0 // Persist until we manually remove or update\n                });\n\n                const enhanced = await enhancePrompt(selectedText);\n\n                // Send the result to the content script for injection\n                chrome.tabs.sendMessage(tab.id, {\n                    action: 'injectPrompt',\n                    prompt: { content: enhanced }\n                });\n\n                // Standard notifications handle the \"Success\" part if needed, \n                // but we definitely want to clear the loading one\n            } catch (err) {\n                logger.error('DynamicMenus', '\u274c Enhance failed:', err);\n                chrome.tabs.sendMessage(tab.id, { \n                    action: 'showNotification', \n                    message: '\u274c Failed to enhance selection.', \n                    type: 'error' \n                });\n            }\n            return;\n        }\n\n        // ========================================================================\n        // SYNC PROMPTS - Force refresh from dashboard\n        // ========================================================================\n        // ========================================================================\n        // SEARCH PROMPTS - Open search overlay\n        // ========================================================================\n        if (info.menuItemId === 'brainbox_inject_search') {\n            chrome.tabs.sendMessage(tab.id, { \n                action: 'showPromptMenu',\n                mode: 'search' \n            }).catch(err => {\n                logger.error('DynamicMenus', '\u274c Search failed:', err);\n            });\n            return;\n        }\n\n        // ========================================================================\n        // INJECT PROMPT - Insert prompt content into textarea\n        // ========================================================================\n        if (typeof info.menuItemId === 'string' && \n            (info.menuItemId.startsWith('brainbox_inject_prompt_') || info.menuItemId.startsWith('brainbox_inject_prompt_quick_'))) {\n            \n            const promptId = info.menuItemId\n                .replace('brainbox_inject_prompt_quick_', '')\n                .replace('brainbox_inject_prompt_', '');\n            \n            // Fetch content (quick cache lookup)\n            const prompt = await this.syncManager.getQuickPrompt(promptId);\n            \n            if (prompt && prompt.content) {\n                this.injectPrompt(tab.id, prompt);\n            }\n        }\n    }\n\n    injectPrompt(tabId: number, prompt: any) {\n        // Send message to content script to insert text\n        // Must match API expected by apps/extension/src/prompt-inject/prompt-inject.js\n        chrome.tabs.sendMessage(tabId, {\n            action: 'injectPrompt',\n            prompt: prompt\n        }).catch(err => {\n            logger.error('DynamicMenus', '\u274c Injection failed:', err);\n            // Fallback?\n        });\n    }\n}\n",
  "apps/extension/src/background/modules/platformAdapters/index.ts": "/**\n * Platform Adapters Index\n * Factory pattern for platform-specific adapters\n */\n\nimport { ChatGPTAdapter } from './chatgpt.adapter';\nimport { ClaudeAdapter } from './claude.adapter';\nimport { GeminiAdapter } from './gemini.adapter';\nimport { DeepSeekAdapter } from './deepseek.adapter';\nimport { PerplexityAdapter } from './perplexity.adapter';\nimport { GrokAdapter } from './grok.adapter';\nimport { QwenAdapter } from './qwen.adapter';\nimport { LMArenaAdapter } from './lmarena.adapter';\nimport type { IPlatformAdapter } from './base';\n\n// Adapter registry\nconst adapters: Record<string, IPlatformAdapter> = {\n    // Original platforms\n    chatgpt: new ChatGPTAdapter(),\n    claude: new ClaudeAdapter(),\n    gemini: new GeminiAdapter(),\n    \n    // New platforms (2026)\n    deepseek: new DeepSeekAdapter(),\n    perplexity: new PerplexityAdapter(),\n    grok: new GrokAdapter(),\n    qwen: new QwenAdapter(),\n    lmarena: new LMArenaAdapter()\n};\n\n/**\n * Get platform adapter by name\n * @throws Error if platform is not supported\n */\nexport function getAdapter(platform: string): IPlatformAdapter {\n    const adapter = adapters[platform];\n    if (!adapter) {\n        throw new Error(`Unsupported platform: ${platform}`);\n    }\n    return adapter;\n}\n\n/**\n * Check if platform is supported\n */\nexport function isPlatformSupported(platform: string): boolean {\n    return platform in adapters;\n}\n\n/**\n * Get list of all supported platforms\n */\nexport function getSupportedPlatforms(): string[] {\n    return Object.keys(adapters);\n}\n\n/**\n * Fetch conversation from any supported platform\n * Delegates to the appropriate platform adapter\n */\nexport async function fetchConversation(platform: string, id: string, url?: string, payload?: any) {\n    return getAdapter(platform).fetchConversation(id, url, payload);\n}\n\n// Export adapters for testing\nexport {\n    ChatGPTAdapter,\n    ClaudeAdapter,\n    GeminiAdapter,\n    DeepSeekAdapter,\n    PerplexityAdapter,\n    GrokAdapter,\n    QwenAdapter,\n    LMArenaAdapter\n};\n\nexport type { IPlatformAdapter } from './base';\n",
  "apps/extension/src/background/modules/platformAdapters/base.ts": "/**\n * Base Platform Adapter\n * \n * Provides common interface and utilities for all platform adapters\n */\n\nexport interface Conversation {\n    id: string;\n    title: string;\n    platform: string;\n    messages: Message[];\n    url?: string;\n    created_at?: number;\n    updated_at?: number;\n}\n\nexport interface Message {\n    role: 'user' | 'assistant' | 'system';\n    content: string;\n    timestamp?: number;\n}\n\n/**\n * Platform Adapter Interface\n * All platform-specific adapters must implement this interface\n */\nexport interface IPlatformAdapter {\n    readonly platform: string;\n    fetchConversation(id: string, url?: string, payload?: any): Promise<Conversation>;\n}\n\n/**\n * Base adapter class with shared utilities\n */\nexport abstract class BasePlatformAdapter implements IPlatformAdapter {\n    abstract readonly platform: string;\n\n    /**\n     * Get token from chrome.storage.local\n     */\n    protected async getStorageToken(key: string): Promise<string> {\n        const result = await chrome.storage.local.get([key]);\n        if (!result[key]) {\n            throw new Error(`Token not found: ${key}. Please refresh the page.`);\n        }\n        return result[key];\n    }\n\n    /**\n     * Get multiple values from chrome.storage.local\n     */\n    protected async getStorageValues(keys: string[]): Promise<Record<string, any>> {\n        const result = await chrome.storage.local.get(keys);\n        return result;\n    }\n\n    /**\n     * Remove tokens from storage (on expiration)\n     */\n    protected async removeStorageKeys(keys: string[]): Promise<void> {\n        await chrome.storage.local.remove(keys);\n    }\n\n    /**\n     * Fetch conversation from platform API\n     */\n    abstract fetchConversation(conversationId: string, url?: string, payload?: any): Promise<Conversation>;\n}\n"
}